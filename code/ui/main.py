## @package main
#  @mainpage
#  UI for the PWM Box headlight tester
#  @author Jose Manuel Garcia Cazorla <jmgarcaz@correo.ugr.es>
#  @copyright (C) GranaSAT, GNU General Public License Version 3

import sys
import time
import re

import qt_themes

from PySide6.QtCore import Qt, QFileInfo, QTimer, QThreadPool, QRunnable, Signal
from PySide6.QtWidgets import QCheckBox, QFileDialog, QListWidgetItem, QSplashScreen
from PySide6.QtGui import QIcon, QPixmap

from pwmbox import PWM, Slot, PWMBox
from json_manager import json_file

from main_window import *
from pass_window import *
from save_window import *
from send_window import *
from rename_window import *
from wait_window import *


## Thread to be called when sending slots to the device. Allows to wait for the
## device to receive data without blocking the UI thread
class SerialThread(QRunnable):
    ## Constructor
    #  @param self Object pointer
    #  @param fn The function to be run
    #  @param parent The window's parent
    def __init__(self, fn, parent) -> None:
        super().__init__()

        self.signals = ThreadSignals()

        self.parent = parent
        self.function = fn

    ## Thread task
    #  @param self Object pointer
    def run(self) -> None:
        self.function()
        self.signals.finished.emit()


## Thread's signals. Need it to be able to connect the signals, since they have
## to be defined in a QObject subclass
#  @see https://stackoverflow.com/questions/36559713/pyside-qtcore-signal-object-has-no-attribute-connect
class ThreadSignals(QObject):
    finished = Signal()


# Window displayed when sending slots
class WaitWindow(QWidget):
    ## Constructor
    #  @param self Object pointer
    #  @param parent The window's parent
    def __init__(self, parent) -> None:
        super().__init__()

        self.parent = parent

        self.ui = Ui_WaitWindow()
        self.ui.setupUi(self)


## Window displayed to change the password
class PassWindow(QWidget):
    ## Constructor
    #  @param self Object pointer
    #  @param parent The window's parent
    #  @param msg Message to display above the input field
    #  @param exitable Whether or not the window can be closed without setting a password
    def __init__(self, parent, msg: str, exitable: bool) -> None:
        super().__init__()

        # Set parent window
        self.parent = parent

        # Set UI to the generated by pyside6-uic
        self.ui = Ui_PassWindow()
        self.ui.setupUi(self)

        # Group elements so they're easier to manage
        self.pass_values = [
            self.ui.pass_value1,
            self.ui.pass_value2,
            self.ui.pass_value3,
        ]

        # Init UI elements
        for i in range(3):
            self.pass_values[i].setValue(self.parent.device.password[i])
        self.ui.pass_label.setText(msg)
        self.ui.close_button.setEnabled(exitable)
        self.ui.pass_confirm.setEnabled(False)
        self.ui.pass_cancel.setEnabled(False)

        # Connect signals to their slots
        for i in self.pass_values:
            i.valueChanged.connect(self.on_pass_edit)
        self.ui.pass_confirm.clicked.connect(self.on_pass_confirm)
        self.ui.pass_cancel.clicked.connect(self.on_pass_cancel)
        self.ui.close_button.clicked.connect(self.on_close)

    ## Triggers when the input text field is edited
    #  @param self Object pointer
    def on_pass_edit(self) -> None:
        self.ui.pass_confirm.setEnabled(True)
        self.ui.pass_cancel.setEnabled(True)

    ## Triggers when the confirm button is clicked
    #  @param self Object pointer
    def on_pass_confirm(self) -> None:
        self.parent.device.set_password(
            [
                self.ui.pass_value1.value(),
                self.ui.pass_value2.value(),
                self.ui.pass_value3.value(),
            ]
        )
        self.ui.pass_confirm.setEnabled(False)
        self.ui.pass_cancel.setEnabled(False)
        self.ui.close_button.setEnabled(True)

    ## Triggers when the cancel button is clicked
    #  @param self Object pointer
    def on_pass_cancel(self) -> None:
        self.ui.pass_value1.setValue(self.parent.device.password[0])
        self.ui.pass_value2.setValue(self.parent.device.password[1])
        self.ui.pass_value3.setValue(self.parent.device.password[2])

        self.ui.pass_confirm.setEnabled(False)
        self.ui.pass_cancel.setEnabled(False)

    ## Triggers when the close button is clicked
    #  @param self Object pointer
    def on_close(self) -> None:
        self.close()


## Window displayed when renaming slots
class RenameWindow(QWidget):
    ## Constructor
    #  @param self Object pointer
    #  @param parent The window's parent
    def __init__(self, parent) -> None:
        super().__init__()

        # Set parent window
        self.parent = parent

        # Set UI to the generated by pyside6-uic
        self.ui = Ui_RenameWindow()
        self.ui.setupUi(self)

        # Initialize UI elements
        self.ui.name_value.setText(
            self.parent.all_slots[self.parent.active_slot].name
        )
        self.ui.name_confirm.setEnabled(False)
        self.ui.name_cancel.setEnabled(False)

        # Connect signals to their slots
        self.ui.name_value.textEdited.connect(self.on_name_edit)
        self.ui.name_confirm.clicked.connect(self.on_confirm)
        self.ui.name_cancel.clicked.connect(self.on_cancel)
        self.ui.close_button.clicked.connect(self.on_close)

    ## Triggers when the input text field is edited
    #  @param self Object pointer
    def on_name_edit(self):
        self.ui.name_confirm.setEnabled(True)
        self.ui.name_cancel.setEnabled(True)

    ## Triggers the confirm button is clicked
    #  @param self Object pointer
    def on_confirm(self):
        self.parent.all_slots[self.parent.active_slot].name = self.ui.name_value.text()

        self.parent.ui.slot_value.setItemText(
            self.parent.ui.slot_value.currentIndex(), self.ui.name_value.text()
        )

        self.ui.name_confirm.setEnabled(False)
        self.ui.name_cancel.setEnabled(False)

    ## Triggers when the cancel button is clicked
    #  @param self Object pointer
    def on_cancel(self):
        self.ui.name_value.setText(self.parent.all_slots[self.parent.active_slot].name)

        self.ui.name_confirm.setEnabled(False)
        self.ui.name_cancel.setEnabled(False)

    ## Triggers when the close button is clicked
    #  @param self Object pointer
    def on_close(self):
        self.close()


## Window displayed to select which slots will be exported
class SaveWindow(QWidget):
    ## Constructor
    #  @param self Object pointer
    #  @param parent The window's parent
    def __init__(self, parent) -> None:
        super().__init__()

        self.parent = parent
        self.checkboxes: list[QCheckBox] = []  # All the checkboxes (to manage them easily)

        self.checked: list[int] = []  # Checked boxes

        # Set UI to the generated by pyside6-uic
        self.ui = Ui_SaveWindow()
        self.ui.setupUi(self)

        # Add a checkbox for each loaded slot
        for i in range(len(self.parent.all_slots)):
            new = QCheckBox(self.parent.all_slots[i].name, self)  # Set name and parent
            new.setMaximumSize(1000, 20)  # Set size
            new.checkStateChanged.connect(lambda x, idx=i: self.on_check(x, idx))  # Connect signal to slot

            self.checkboxes.append(new)
            self.ui.slots_layout.addWidget(new)

        # Set window size based on the amount of checkboxes
        self.setMinimumSize(240, len(self.parent.all_slots) * 25 + 100)
        self.setMaximumSize(240, len(self.parent.all_slots) * 25 + 100)

        # Connect remaining signals to their slots
        self.ui.all_button.checkStateChanged.connect(self.on_check_all)
        self.ui.confirm_button.clicked.connect(self.on_save_confirm)
        self.ui.cancel_button.clicked.connect(self.on_save_cancel)

    ## Triggers when the "Select all" checkbox is clicked
    #  @param self Object pointer
    #  @param new_state The checkbox' new state
    def on_check_all(self, new_state) -> None:
        if new_state is Qt.CheckState.Checked:
            for i in self.checkboxes:
                i.setCheckState(Qt.CheckState.Checked)
                i.setEnabled(False)
        else:
            for i in self.checkboxes:
                i.setCheckState(Qt.CheckState.Unchecked)
                i.setEnabled(True)

    ## Triggers when a checkbox' state is changed
    #  @param self Object pointer
    #  @param new_state The checkbox' new state
    #  @param idx Index of the checked box
    def on_check(self, new_state, idx: int) -> None:
        if new_state is Qt.CheckState.Checked:
            self.checked.append(idx)
        else:
            self.checked.remove(idx)

    ## Triggers when the confirm button is clicked
    #  @param self Object pointer
    def on_save_confirm(self) -> None:
        # Set up the dialog displayed to select the file location
        dialog = QFileDialog(
            caption="Export file",
            filter="JSON file (*.json)"
        )
        dialog.setOptions(QFileDialog.Option.DontUseNativeDialog)
        dialog.setFileMode(QFileDialog.FileMode.AnyFile)
        dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)
        dialog.setViewMode(QFileDialog.ViewMode.Detail)
        dialog.setDirectory("./exports")
        dialog.setDefaultSuffix("json")

        if dialog.exec():
            selected = dialog.selectedFiles()[0]
            info = QFileInfo(selected)
            file = json_file(info.absoluteFilePath())

            self.checked.sort()

            # Get the slots that correspond to the checked boxes
            to_save: list[Slot] = []

            for i in self.checked:
                to_save.append(self.parent.all_slots[i])

            file.from_slots(to_save)
            file.save()

            self.close()

        # Move exported slots to our imported list
        for i in self.checked:
            for j in self.parent.spare_slots:
                if j.name == self.ui.right_list.item(i).text():
                    self.parent.imported_slots.append(j)
                    self.parent.spare_slots.remove(j)

        self.parent.update_slots()

    ## Triggers when the close button is clicked
    #  @param self Object pointer
    def on_save_cancel(self) -> None:
        self.close()


## Window displayed to select which slots will be sent to the device
class SendWindow(QWidget):
    ## Constructor
    #  @param self Object pointer
    #  @param parent The window's parent
    def __init__(self, parent) -> None:
        super().__init__()

        # Set parent window
        self.parent = parent
        self.wait_win = None

        # Set UI to the generated by pyside6-uic
        self.ui = Ui_SendWindow()
        self.ui.setupUi(self)

        # Initialize UI elements
        for i in self.parent.imported_slots:
            self.ui.left_list.addItem(i.name)
        for i in self.parent.spare_slots:
            self.ui.left_list.addItem(i.name)

        for i in self.parent.device.slots:
            self.ui.right_list.addItem(i.name)

        # Connect signals to their slots
        self.ui.to_left_button.clicked.connect(self.on_to_left_button)
        self.ui.to_right_button.clicked.connect(self.on_to_right_button)
        self.ui.confirm_button.clicked.connect(self.on_confirm_button)
        self.ui.cancel_button.clicked.connect(self.on_cancel_button)
        self.ui.left_list.currentRowChanged.connect(
            self.on_left_selection_change
        )
        self.ui.right_list.currentRowChanged.connect(
            self.on_right_selection_change
        )

    ## Triggers when the "Move to the right" button is clicked
    #  @param self Object pointer
    def on_to_right_button(self) -> None:
        self.ui.right_list.addItem(
            self.ui.left_list.takeItem(self.ui.left_list.currentRow())
        )

        if self.ui.right_list.count() > self.parent.device.max_slots:
            self.ui.confirm_button.setEnabled(False)

    ## Triggers when the "Move to the left" button is clicked
    #  @param self Object pointer
    def on_to_left_button(self) -> None:
        self.ui.left_list.addItem(
            self.ui.right_list.takeItem(self.ui.right_list.currentRow())
        )

        if self.ui.right_list.count() <= self.parent.device.max_slots:
            self.ui.confirm_button.setEnabled(True)
    
    ## Triggers when an item on the left list is selected
    #  @param self Object pointer
    #  @param new Newly selected item from the list
    def on_left_selection_change(self, new) -> None:
        self.ui.right_list.setCurrentRow(-1)  # Deselect item from the opposite list

        # This prevents sometimes needing to click an item twice to select it
        self.ui.left_list.setCurrentRow(new)

    ## Triggers when an item on the right list is selected
    #  @param self Object pointer
    #  @param new Newly selected item from the list
    def on_right_selection_change(self, new) -> None:
        self.ui.left_list.setCurrentRow(-1)  # Deselect item from the opposite list
        
        # This prevents sometimes needing to click an item twice to select it
        self.ui.right_list.setCurrentRow(new)

    ## Triggers when the confirm button is selected
    #  @param self Object pointer
    def on_confirm_button(self) -> None:
        # Reorganize our slot lists
        for i in range(self.ui.left_list.count()):
            for j in self.parent.device.slots:
                if j.name == self.ui.left_list.item(i).text():
                    self.parent.spare_slots.append(j)
                    self.parent.device.slots.remove(j)

        for i in range(self.ui.right_list.count()):
            for j in self.parent.imported_slots:
                if j.name == self.ui.right_list.item(i).text():
                    self.parent.device.slots.append(j)
                    self.parent.imported_slots.remove(j)

            for j in self.parent.spare_slots:
                if j.name == self.ui.right_list.item(i).text():
                    self.parent.device.slots.append(j)
                    self.parent.spare_slots.remove(j)

        # Sort them alphabetically
        self.parent.device.slots.sort()
        self.parent.imported_slots.sort()
        self.parent.spare_slots.sort()

        self.wait_win = WaitWindow(self)

        thread = SerialThread(self.parent.device.set_slots, self.wait_win)
        thread.signals.finished.connect(self.on_thread_complete)
        self.parent.threadpool.start(thread)

        self.wait_win.show()

        self.close()

    ## Triggers when the cancel button is selected
    #  @param self Object pointer
    def on_cancel_button(self) -> None:
        self.close()

    def on_thread_complete(self):
        self.parent.update_slots()
        self.wait_win.close()


## Main window of the application
class MainWindow(QMainWindow):
    ## Constructor
    #  @param self Object pointer
    #  @param splash Shown splashscreen
    def __init__(self, splash):
        super().__init__()

        self.threadpool = QThreadPool()

        # Child windows
        self.pass_win = None
        self.save_win = None
        self.send_win = None
        self.rename_win = None

        splash.showMessage("Inicializando interfaz...")

        # Set UI to the generated by pyside6-uic
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # Group elements so they're easier to manage
        self.pwm_names = [
            self.ui.name1_value, self.ui.name2_value,
            self.ui.name3_value, self.ui.name4_value,
            self.ui.name5_value, self.ui.name6_value,
            self.ui.name7_value, self.ui.name8_value,
        ]
        self.pwm_name_confirms = [
            self.ui.name1_confirm, self.ui.name2_confirm,
            self.ui.name3_confirm, self.ui.name4_confirm,
            self.ui.name5_confirm, self.ui.name6_confirm,
            self.ui.name7_confirm, self.ui.name8_confirm,
        ]
        self.pwm_name_cancels = [
            self.ui.name1_cancel, self.ui.name2_cancel,
            self.ui.name3_cancel, self.ui.name4_cancel,
            self.ui.name5_cancel, self.ui.name6_cancel,
            self.ui.name7_cancel, self.ui.name8_cancel,
        ]
        self.pwm_modes = [
            self.ui.mode1_value, self.ui.mode2_value,
            self.ui.mode3_value, self.ui.mode4_value,
            self.ui.mode5_value, self.ui.mode6_value,
            self.ui.mode7_value, self.ui.mode8_value,
        ]
        self.pwm_frqs = [
            self.ui.frq1_value, self.ui.frq2_value,
            self.ui.frq3_value, self.ui.frq4_value,
            self.ui.frq5_value, self.ui.frq6_value,
            self.ui.frq7_value, self.ui.frq8_value,
        ]
        self.pwm_dtys = [
            self.ui.dty1_value, self.ui.dty2_value,
            self.ui.dty3_value, self.ui.dty4_value,
            self.ui.dty5_value, self.ui.dty6_value,
            self.ui.dty7_value, self.ui.dty8_value,
        ]
        self.pwm_phss = [
            self.ui.phs1_value, self.ui.phs2_value,
            self.ui.phs3_value, self.ui.phs4_value,
            self.ui.phs5_value, self.ui.phs6_value,
            self.ui.phs7_value, self.ui.phs8_value,
        ]

        splash.showMessage("Conectando al dispositivo...")

        # Find, connect and get the device's info
        self.device = PWMBox()
        self.active_slot = None

        # Store slots imported from files or created from the app
        self.imported_slots: list[Slot] = []
        self.spare_slots: list[Slot] = []

        self.all_slots = self.device.slots + self.imported_slots + self.spare_slots

        # Configure all the UI elements
        self.ui_setup()
        self.setFixedWidth(self.ui.central_widget.sizeHint().width() + 30)

        splash.showMessage("Iniciando...")

        QTimer.singleShot(3000, self, self.show)
        QTimer.singleShot(3000, splash, splash.close)

    ## Sets the elements' starting configuration
    #  @param self Object pointer
    def ui_setup(self) -> None:
        # If device is not connected/found, most elements should be disabled
        if self.device.serial is None:
            self.ui.port_value.setText("...")
            self.ui.desc_value.setText("...")
            self.ui.serial_value.setText("...")
            self.ui.hwver_value.setText("...")
            self.ui.swver_value.setText("...")

            self.ui.slot_value.setEnabled(False)
            self.ui.send_button.setEnabled(False)
            self.ui.import_button.setEnabled(False)
            self.ui.export_button.setEnabled(False)
            self.ui.pass_button.setEnabled(False)
            self.ui.slot_rename_button.setEnabled(False)
            self.ui.slot_new_button.setEnabled(False)
            self.ui.send_action.setEnabled(False)
            self.ui.import_action.setEnabled(False)
            self.ui.export_action.setEnabled(False)
            self.ui.pass_action.setEnabled(False)

            for i in range(self.device.NUM_PWMS):
                self.pwm_names[i].setEnabled(False)
                self.pwm_modes[i].setEnabled(False)
                self.pwm_frqs[i].setEnabled(False)
                self.pwm_dtys[i].setEnabled(False)
                self.pwm_phss[i].setEnabled(False)

        # Make sure the corresponding elements are enabled so the whole UI can be reloaded
        else:
            self.ui.port_value.setText(self.device.port)
            self.ui.desc_value.setText(self.device.description)
            self.ui.serial_value.setText(str(self.device.serial_num))
            self.ui.hwver_value.setText(str(self.device.hw_version))
            self.ui.swver_value.setText(str(self.device.sw_version))
            
            self.ui.slot_value.setEnabled(True)
            self.ui.send_button.setEnabled(True)
            self.ui.import_button.setEnabled(True)
            self.ui.export_button.setEnabled(True)
            self.ui.pass_button.setEnabled(True)
            self.ui.send_action.setEnabled(True)
            self.ui.slot_rename_button.setEnabled(True)
            self.ui.slot_new_button.setEnabled(True)
            self.ui.import_action.setEnabled(True)
            self.ui.export_action.setEnabled(True)
            self.ui.pass_action.setEnabled(True)

            for i in range(self.device.NUM_PWMS):
                self.pwm_names[i].setEnabled(True)
                self.pwm_modes[i].setEnabled(True)
                self.pwm_frqs[i].setEnabled(True)
                self.pwm_dtys[i].setEnabled(True)
                self.pwm_phss[i].setEnabled(True)

            for i in self.all_slots:
                self.ui.slot_value.addItem(QIcon("res/icons/computer.png"), i.name)

            # Activate default Slot
            self.active_slot = self.device.default_slot

            # Ask for a password if one is not set already
            if self.device.password[0] == -1:
                self.pass_window("Establezca una contraseña.", False)

        # Some other elements depend on whether or not a default slot is set
        if self.active_slot is None:
            self.ui.defslot_value.setText("Ninguno")
            self.ui.slot_rename_button.setEnabled(False)
            self.ui.slot_default_button.setEnabled(False)
        else:
            self.ui.slot_value.setCurrentIndex(self.active_slot)
            self.ui.defslot_value.setText(
                self.device.slots[self.device.default_slot].name
            )

        # Others are always disabled by default
        for i in range(0, self.device.NUM_PWMS):
            self.pwm_name_confirms[i].setEnabled(False)
            self.pwm_name_cancels[i].setEnabled(False)
        self.ui.slot_delete_button.setEnabled(False)

        # Reload button should always be enabled
        self.ui.reload_action.setEnabled(True)
        self.ui.reload_button.setEnabled(True)

        # Connect signals to their slots
        self.ui.slot_value.currentIndexChanged.connect(self.on_slot_change)
        for i in range(self.device.NUM_PWMS):
            self.pwm_names[i].textEdited.connect(
                lambda x, i=i: self.on_name_edit(i)
            )
            self.pwm_name_confirms[i].clicked.connect(
                lambda x, i=i: self.on_name_confirm(i)
            )
            self.pwm_name_cancels[i].clicked.connect(
                lambda x, i=i: self.on_name_cancel(i)
            )
            self.pwm_modes[i].currentIndexChanged.connect(
                lambda x, i=i: self.on_pwm_mode_change(x, i)
            )
            self.pwm_frqs[i].valueChanged.connect(
                lambda x, i=i: self.on_pwm_frq_change(x, i)
            )
            self.pwm_dtys[i].valueChanged.connect(
                lambda x, i=i: self.on_pwm_dty_change(x, i)
            )
            self.pwm_phss[i].valueChanged.connect(
                lambda x, i=i: self.on_pwm_phs_change(x, i)
            )
        self.ui.reload_button.clicked.connect(self.on_reload)
        self.ui.send_button.clicked.connect(self.on_send_slots)
        self.ui.import_button.clicked.connect(self.on_import_slots)
        self.ui.export_button.clicked.connect(self.on_export_slots)
        self.ui.pass_button.clicked.connect(
            lambda x, m="Cambio de contraseña:": self.pass_window(m, True)
        )
        self.ui.reload_action.triggered.connect(self.on_reload)
        self.ui.send_action.triggered.connect(self.on_send_slots)
        self.ui.import_action.triggered.connect(self.on_import_slots)
        self.ui.export_action.triggered.connect(self.on_export_slots)
        self.ui.pass_action.triggered.connect(
            lambda x, m="Cambio de contraseña:": self.pass_window(m, True)
        )
        self.ui.slot_rename_button.clicked.connect(self.on_slot_rename)
        self.ui.slot_default_button.clicked.connect(self.on_slot_default)
        self.ui.slot_new_button.clicked.connect(self.on_slot_new)
        self.ui.slot_delete_button.clicked.connect(self.on_slot_delete)

        # Update PWM parameters
        self.update_pwms()

    ## Updates the PWMs information
    #  @param self Object pointer
    def update_pwms(self) -> None:
        if self.active_slot is None:
            for i in range(self.device.NUM_PWMS):
                self.pwm_names[i].setText("")
                self.pwm_modes[i].setCurrentIndex(0)
                self.pwm_frqs[i].setValue(0)
                self.pwm_dtys[i].setValue(0)
                self.pwm_phss[i].setValue(0)
        else:
            for i in range(self.device.NUM_PWMS):
                self.pwm_names[i].setText(
                    self.all_slots[self.active_slot].pwms[i].name
                )
                self.pwm_modes[i].setCurrentIndex(
                    int(self.all_slots[self.active_slot].pwms[i].mode)
                )
                self.pwm_frqs[i].setValue(
                    float(self.all_slots[self.active_slot].pwms[i].frq)
                )
                self.pwm_dtys[i].setValue(
                    int(self.all_slots[self.active_slot].pwms[i].dty)
                )
                self.pwm_phss[i].setValue(
                    int(self.all_slots[self.active_slot].pwms[i].phs)
                )

    ## Updates the slot list
    #  @param self Object pointer
    def update_slots(self) -> None:
        # Save the currently selected slot
        selected_slot = self.active_slot

        # Delete every element
        self.ui.slot_value.clear()

        # Add them again
        for i in self.device.slots:
            self.ui.slot_value.addItem(QIcon("res/icons/computer.png"), i.name)
        for i in self.imported_slots:
            self.ui.slot_value.addItem(QIcon("res/icons/blue-document-text.png"), i.name)
        for i in self.spare_slots:
            self.ui.slot_value.addItem(i.name)

        # Update our slot list
        self.all_slots = self.device.slots + self.imported_slots + self.spare_slots

        # Restore the selected slot
        if selected_slot is not None:
            self.ui.slot_value.setCurrentIndex(selected_slot)

    ## Shows the password window. Triggers when the password button is clicked, as well as
    ## on startup when no password is set
    #  @param self Object pointer
    #  @param msg Message to display above the input field
    #  @param exitable Whether or not the window can be closed without setting a password
    def pass_window(self, msg: str, exitable: bool) -> None:
        self.pass_win = PassWindow(self, msg, exitable)
        self.pass_win.show()

    ## Triggers when selecting a new slot from the list
    #  @param self Object pointer
    def on_slot_change(self) -> None:
        s = self.active_slot
        self.active_slot = self.ui.slot_value.currentIndex()
        self.ui.slot_rename_button.setEnabled(True)

        # If the slot is stored in the app or imported, allow deleting it
        if self.active_slot >= len(self.device.slots):
            self.ui.slot_delete_button.setEnabled(True)
        else:
            self.ui.slot_delete_button.setEnabled(False)

        # If the slot is currently loaded in the device, allow setting it as default
        if 0 <= self.active_slot < len(self.device.slots):
            self.ui.slot_default_button.setEnabled(True)
        else:
            self.ui.slot_default_button.setEnabled(False)

        self.update_pwms()

    ## Triggers when the "Rename slot" button is clicked
    #  @param self Object pointer
    def on_slot_rename(self) -> None:
        self.rename_win = RenameWindow(self)
        self.rename_win.show()

    ## Triggers when the "Set as default" button is clicked
    #  @param self Object pointer
    def on_slot_default(self) -> None:
        self.device.set_default(self.active_slot)
        self.ui.defslot_value.setText(self.device.slots[self.active_slot].name)

    ## Triggers when the "New slot" button is clicked
    #  @param self Object pointer
    def on_slot_new(self) -> None:
        self.spare_slots.append(
            Slot("Nuevo", [
                PWM("PWM 1", 0, 0, 0, 0),
                PWM("PWM 2", 0, 0, 0, 0),
                PWM("PWM 3", 0, 0, 0, 0),
                PWM("PWM 4", 0, 0, 0, 0),
                PWM("PWM 5", 0, 0, 0, 0),
                PWM("PWM 6", 0, 0, 0, 0),
                PWM("PWM 7", 0, 0, 0, 0),
                PWM("PWM 8", 0, 0, 0, 0),
            ])
        )

        # Activate the newly added slot
        self.active_slot = len(self.all_slots)
        self.update_slots()

    ## Triggers when the "Delete slot" button is clicked
    #  @param self Object pointer
    def on_slot_delete(self) -> None:
        if self.active_slot < (len(self.device.slots) + len(self.imported_slots)):
            self.imported_slots.pop(self.active_slot - len(self.device.slots))
        else:
            self.spare_slots.pop(
                self.active_slot - (len(self.device.slots) + len(self.imported_slots))
            )

        # Activate the previous slot in the list
        self.active_slot = self.active_slot - 1
        self.update_slots()

    ## Triggers when a PWM's name field is edited
    #  @param self Object pointer
    #  @param idx Index of the edited name
    def on_name_edit(self, idx: int) -> None:
        self.pwm_name_confirms[idx].setEnabled(True)
        self.pwm_name_cancels[idx].setEnabled(True)

    ## Triggers when a PWM's "Confirm name change" button is clicked
    #  @param self Object pointer
    #  @param idx Index of the changed name
    def on_name_confirm(self, idx: int) -> None:
        self.all_slots[self.active_slot].pwms[idx].name = self.pwm_names[idx].text()
        self.pwm_name_confirms[idx].setEnabled(False)
        self.pwm_name_cancels[idx].setEnabled(False)

    ## Triggers when a PWM's "Cancel name change" button is clicked
    #  @param self Object pointer
    #  @param idx Index of the non-changed name
    def on_name_cancel(self, idx: int) -> None:
        self.pwm_names[idx].setText(self.device.slots[self.active_slot].pwms[idx].name)
        self.pwm_name_confirms[idx].setEnabled(False)
        self.pwm_name_cancels[idx].setEnabled(False)

    ## Triggers when a PWM's mode is changed
    #  @param self Object pointer
    #  @param new New mode's index
    #  @param idx Index of the changed mode
    def on_pwm_mode_change(self, new, idx: int):
        self.all_slots[self.active_slot].pwms[idx].mode = new

    ## Triggers when a PWM's frequency is changed
    #  @param self Object pointer
    #  @param new New frequency value
    #  @param idx Index of the changed frequency
    def on_pwm_frq_change(self, new, idx: int):
        self.all_slots[self.active_slot].pwms[idx].frq = new

    ## Triggers when a PWM's duty is changed
    #  @param self Object pointer
    #  @param new New duty cycle value
    #  @param idx Index of the changed duty cycle
    def on_pwm_dty_change(self, new, idx: int):
        self.all_slots[self.active_slot].pwms[idx].dty = new

    ## Triggers when a PWM's phase is changed
    #  @param self Object pointer
    #  @param new New phase value
    #  @param idx Index of the changed phase
    def on_pwm_phs_change(self, new, idx: int):
        self.all_slots[self.active_slot].pwms[idx].phs = new

    ## Shows a slot selection window. Triggers when the "Send slots" button is clicked
    #  @param self Object pointer
    def on_send_slots(self) -> None:
        self.send_win = SendWindow(self)
        self.send_win.show()

    ## Reloads the device connection entirely, searching for it if it's not currently found and getting all its info.
    ## Triggers when the reload button is clicked
    #  @param self Object pointer
    def on_reload(self) -> None:
        if self.device is None:
            self.device.connect()

        self.device.get_info()
        self.device.get_password()
        self.device.get_slots()

        self.update_slots()
        self.ui_setup()

    ## Shows a slot selection window. Triggers when the "Export slots" button is clicked
    #  @param self Object pointer
    def on_export_slots(self) -> None:
        self.save_win = SaveWindow(self)
        self.save_win.show()

    ## Shows a file selection window. Triggers when the "Import slots" button is pressed
    #  @param self Object pointer
    def on_import_slots(self) -> None:
        # Set up the dialog displayed to select the file location
        dialog = QFileDialog(
            caption="Import file",
            filter="JSON file (*.json)"
        )
        dialog.setOptions(QFileDialog.Option.DontUseNativeDialog)
        dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
        dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptOpen)
        dialog.setViewMode(QFileDialog.ViewMode.Detail)
        dialog.setDirectory("./exports")
        dialog.setDefaultSuffix("json")

        if dialog.exec():
            selected = dialog.selectedFiles()[0]
            path = QFileInfo(selected).absoluteFilePath()

            file = json_file(path)
            file.load()

            # Adds slots to our imported slots list
            for i in file.to_slots():
                self.imported_slots.append(i)

            self.update_slots()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    qt_themes.set_theme("catppuccin_latte")

    pixmap = QPixmap("./res/splash.png")
    splash = QSplashScreen(pixmap)
    splash.show()

    main_window = MainWindow(splash)

    sys.exit(app.exec())
